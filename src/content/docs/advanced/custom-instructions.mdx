---
title: "Custom Instructions"
description: "Define repository-wide and path-specific instructions that automatically guide GitHub Copilot's responses to match your coding standards and project requirements."
order: 1
section: "Advanced"
---

Custom instructions let you define guidelines and rules that automatically influence how Copilot generates code. Instead of repeating context in every chat prompt, specify custom instructions in Markdown files to ensure consistent AI responses aligned with your coding practices.

## Instruction File Types

| File | Location | Purpose | Auto-applied |
|------|----------|---------|--------------|
| `copilot-instructions.md` | `.github/` | Repository-wide context | ✅ Yes |
| `*.instructions.md` | `.github/instructions/` | Path-specific instructions | ✅ Yes (when path matches) |
| `*.prompt.md` | `.github/prompts/` | Reusable task prompts | ❌ Manual attachment |

---

## Repository-Wide Instructions

The `.github/copilot-instructions.md` file provides repository-specific guidance that applies to **all** Copilot requests made in that repository's context.

### File Location

```
.github/copilot-instructions.md
```

### Format

- Plain Markdown with natural language instructions
- No frontmatter required
- Whitespace between instructions is ignored
- Can be written as a single paragraph, each on a new line, or separated by blank lines

### Example

```markdown
# Project Guidelines

## Code Style
- Use 4 spaces for indentation
- Follow PascalCase for public methods, camelCase for private
- Always include XML documentation for public APIs

## Architecture
- Follow Clean Architecture principles
- Keep business logic in Domain layer
- Use dependency injection for all services

## Testing
- Write unit tests for all business logic
- Use xUnit with FluentAssertions
- Mock external dependencies with Moq
```

---

## Path-Specific Instructions

Path-specific instructions apply to **specific file types or paths** rather than all requests. Create files in `.github/instructions/` with the `.instructions.md` extension.

### File Location

```
.github/instructions/<name>.instructions.md
```

### Required Frontmatter

```yaml
---
applyTo: "<glob-pattern>"
---
```

### Glob Pattern Reference

| Pattern | Matches |
|---------|---------|
| `*` | All files in current directory |
| `**` or `**/*` | All files in all directories |
| `*.cs` | All `.cs` files in current directory |
| `**/*.cs` | All `.cs` files recursively |
| `src/*.cs` | `.cs` files in `src/` only (not subdirs) |
| `src/**/*.cs` | `.cs` files in `src/` recursively |
| `**/*.ts,**/*.tsx` | All TypeScript files (multiple patterns) |
| `**/tests/**/*.cs` | C# files in any `tests` folder at any depth |

### Optional: Exclude Agent

```yaml
---
applyTo: "**"
excludeAgent: "code-review"   # Only used by coding agent, not code review
---
```

### Example: C# Instructions

**File:** `.github/instructions/csharp.instructions.md`

```yaml
---
applyTo: "**/*.cs"
---

# C# Conventions

- Use file-scoped namespaces
- Use primary constructors for simple classes
- Prefer records for DTOs and value objects
- Use `required` modifier for mandatory properties
- Initialize collections with collection expressions: [1, 2, 3]

## Async/Await
- Suffix async methods with "Async"
- Use ConfigureAwait(false) in library code
- Prefer ValueTask for hot paths that usually complete synchronously
```

### Example: Test File Instructions

**File:** `.github/instructions/tests.instructions.md`

```yaml
---
applyTo: "**/*.Tests/**/*.cs,**/*Tests.cs"
---

# Testing Guidelines

- Test class naming: {ClassUnderTest}Tests
- Test method naming: {Method}_Should{ExpectedResult}_When{Condition}
- One assertion per test (or one logical assertion)
- Use builder pattern for complex test data setup
- Arrange-Act-Assert structure with blank line separators
```

### Example: API Controllers

**File:** `.github/instructions/api.instructions.md`

```yaml
---
applyTo: "**/Controllers/**/*.cs,**/Endpoints/**/*.cs"
---

# API Development Guidelines

- Use async/await for all action methods
- Validate input with FluentValidation or data annotations
- Return consistent response shapes with ActionResult<T>
- Include proper error handling with ProblemDetails
- Log all errors with correlation IDs
```

---

## Reusable Prompts

Prompt files define reusable prompts for specific tasks that you attach manually to chat requests. Unlike instructions (which apply automatically), prompts are invoked explicitly.

### File Location

```
.github/prompts/<name>.prompt.md
```

### Format

```yaml
---
description: "Brief description shown in UI"
mode: "agent"  # Optional: "agent" or "ask" (default)
---

<prompt content in Markdown>
```

### Example: Code Review Prompt

**File:** `.github/prompts/code-review.prompt.md`

```yaml
---
description: "Perform a thorough code review"
---

Review this code for:

1. **Bugs & Logic Errors**: Check for null references, off-by-one errors, race conditions
2. **Security**: SQL injection, XSS, authentication/authorization issues
3. **Performance**: N+1 queries, unnecessary allocations, missing async
4. **Maintainability**: Complex methods, unclear naming, missing abstractions
5. **Testing**: Suggest test cases that should be added

Be specific about line numbers and provide corrected code snippets.
```

### Example: Documentation Prompt

**File:** `.github/prompts/document-api.prompt.md`

```yaml
---
description: "Generate API documentation"
---

Generate comprehensive documentation for this API endpoint including:

- **Summary**: One-line description
- **Parameters**: Name, type, required/optional, description
- **Request Body**: JSON schema with examples
- **Response**: Success and error response shapes
- **Examples**: curl command and response
- **Error Codes**: Possible error responses and meanings
```

### Example: Agent Mode Prompt

**File:** `.github/prompts/add-tests.prompt.md`

```yaml
---
description: "Add comprehensive unit tests"
mode: "agent"
---

Add unit tests for this code following these guidelines:

- Use the existing test framework in this project
- Cover happy path, edge cases, and error scenarios
- Use descriptive test names: Should_ExpectedResult_When_Condition
- Mock external dependencies
- Aim for high coverage of business logic
```

---

## Enabling in Visual Studio

Custom instructions must be enabled in Visual Studio settings before they take effect.

### Steps to Enable

1. Open **Tools** > **Options**
2. Navigate to **GitHub** > **Copilot** > **Copilot Chat**
3. Check: **"Enable custom instructions to be loaded from .github/copilot-instructions.md files and added to requests"**

### Version Requirements

| Feature | Minimum Version |
|---------|-----------------|
| Basic Copilot Chat | Visual Studio 2022 17.10+ |
| Guided chat experience | Visual Studio 2022 17.12+ |
| Expanded slash commands | Visual Studio 2022 17.13+ |

### Verifying Instructions Are Applied

Custom instructions aren't visible in the Chat view or inline chat input. However, when applied:

- The `.github/copilot-instructions.md` file appears in the **References list** of a response
- Click the reference to open and verify the file

---

## Example Conventions

Here are common conventions you might include in your custom instructions:

### General Coding Standards

```markdown
## Code Style
- Use meaningful variable names (no single letters except loop counters)
- Maximum function length: 30 lines
- Maximum file length: 300 lines
- Prefer composition over inheritance

## Comments
- Code should be self-documenting; add comments only for "why", not "what"
- All public APIs must have XML documentation
- TODOs must include ticket number: // TODO(JIRA-123): description

## Error Handling
- Never swallow exceptions silently
- Use domain-specific exception types
- Log exceptions at the point of handling, not throwing
```

### .NET/C# Specific

```markdown
## C# Conventions
- Use file-scoped namespaces
- Use primary constructors for simple classes
- Prefer records for DTOs and value objects
- Use `required` modifier for mandatory properties

## Dependency Injection
- Register services in extension methods: `services.AddMyFeature()`
- Use IOptions<T> pattern for configuration
- Prefer constructor injection over property injection
```

### Project Architecture

```markdown
## Architecture
- Follow Vertical Slice Architecture for features
- Keep handlers in Features/{FeatureName}/ directories
- Shared code goes in Common/ or Infrastructure/
- DTOs in Contracts/ are the public API contract

## File Organization
- One public type per file
- File name must match type name
- Group related files in feature folders, not by type
```

---

## Best Practices

1. **Keep instructions focused** — Don't overload a single file with every possible guideline. Use path-specific instructions to scope rules appropriately.

2. **Be specific** — Vague instructions like "write good code" don't help. Specific instructions like "use records for DTOs" give Copilot actionable guidance.

3. **Update as your codebase evolves** — Instructions should reflect your current conventions. Review and update them as standards change.

4. **Test your instructions** — After adding instructions, try prompts that would trigger them and verify Copilot's responses align with your expectations.

5. **Combine file types effectively**:
   - Use `copilot-instructions.md` for universal project context
   - Use `.instructions.md` files for language or path-specific rules
   - Use `.prompt.md` files for repeatable tasks you invoke manually

---

## Additional Resources

- [GitHub Docs: Adding repository custom instructions](https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions)
- [Microsoft Learn: Customize chat responses and set context](https://learn.microsoft.com/visualstudio/ide/copilot-chat-context)
- [GitHub awesome-copilot: Community instructions and prompts](https://github.com/github/awesome-copilot)
